ğŸ§¾ 2193E â€” Product Queries (Proper Notes)
ğŸ§© Problem Summary

Given array a (size = n).
You can pick elements multiple times.

For each i (1 â†’ n) find:
ğŸ‘‰ Minimum elements needed so product = i
ğŸ‘‰ If impossible â†’ -1

At least 1 element must be chosen.

ğŸ”‘ Key Observations
âœ… Repetition Allowed

So frequency doesnâ€™t matter â€” only presence matters.

âœ… If number x exists in array

Then:

dp[x] = 1


Because single element can form product.

âœ… Any number can be built using factorization

If:

x = y Ã— z


Then:

dp[x] = dp[y] + dp[z]

ğŸ§  DP Definition
dp[x] = minimum elements needed to make product = x


Initialize:

dp[x] = INF (1e9)

âš¡ Base Case

If array contains value v:

dp[v] = 1

ğŸ”„ Transition

For each divisor pair:

If:

j = i Ã— (j/i)


Then:

dp[j] = min(dp[j], dp[i] + dp[j/i])

ğŸ§® Implementation Trick

Instead of finding divisors â†’
Loop multiples:

for i from 1 â†’ n
    for j = i, 2i, 3i â€¦ â‰¤ n
        dp[j] = min(dp[j], dp[i] + dp[j/i])

ğŸ“¦ Final Step

If:

dp[x] == INF


Then:

answer = -1

â± Complexity
O(n log n)


Because harmonic series of multiples.

ğŸ’¡ Why This Works

Because every number can be broken into:

x = factor1 Ã— factor2


We try all possible splits â†’ take minimum.

ğŸŸ¢ Example

Array:

2 3


Initial:

dp[2]=1
dp[3]=1


Build:

dp[4] = dp[2]+dp[2] = 2
dp[6] = dp[2]+dp[3] = 2
dp[8] = dp[2]+dp[4] = 3

ğŸ”´ Edge Cases
âŒ If 1 not in array

Then:

dp[1] = INF â†’ answer = -1

âŒ If number has factor not buildable

Then remains impossible.

ğŸ§  Memory Trick (Very Important)

ğŸ‘‰ This is Multiplicative Coin Change

Instead of:

sum = coin1 + coin2


We do:

product = factor1 Ã— factor2

ğŸ Code Template (Contest Memory)
dp[x] = INF

for each value v in array:
    dp[v] = 1

for i = 1 â†’ n:
    for j = i â†’ n step i:
        dp[j] = min(dp[j], dp[i] + dp[j/i])

ğŸš¨ Common Mistakes

âŒ Forget to initialize dp with INF
âŒ Use frequency instead of presence
âŒ Forget dp[a[i]] = 1
âŒ Try greedy factor picking
âŒ Try prime factorization per query (TLE risk)

ğŸ§Š Alternative View

Graph shortest path:

Nodes = numbers
Edge = multiply by allowed number
Cost = +1 step

Find shortest path from base numbers.

â­ Difficulty Tag (For Your Brain)

Multiplicative DP

Number Theory + DP

Divisor Optimization

Harmonic Loop Trick
