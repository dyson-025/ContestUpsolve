ğŸƒ Problem Understanding
link: https://codeforces.com/contest/2145/problem/B
You are given:

A deck with cards numbered 1 to n, top â†’ bottom.

Monocarp performs k actions.

Each action is one of:

'0' â†’ removes top card

'1' â†’ removes bottom card

'2' â†’ removes either top or bottom

You must determine for each card:

'+' â†’ definitely still in the deck

'-' â†’ definitely removed

'?' â†’ could be either removed or not, depending on how '2' actions were done.

ğŸ§© Example to Understand
Example 1:
n = 4, k = 2
s = "01"


Initial deck: [1, 2, 3, 4]

1ï¸âƒ£ Action 1: '0' â†’ remove top â†’ remove 1
Deck â†’ [2, 3, 4]

2ï¸âƒ£ Action 2: '1' â†’ remove bottom â†’ remove 4
Deck â†’ [2, 3]

âœ… So final state:

Card 1 â†’ removed ('-')
Card 2 â†’ remains ('+')
Card 3 â†’ remains ('+')
Card 4 â†’ removed ('-')
Output: -++-

Example 2:
n = 3, k = 2
s = "22"


Now both operations can remove either top or bottom.

Possible outcomes:

remove top twice â†’ remove {1,2}, remain {3}

remove bottom twice â†’ remove {3,2}, remain {1}

remove top once, bottom once â†’ remove {1,3}, remain {2}

So:

Card 1 â†’ might be removed, might stay â†’ '?'
Card 2 â†’ might be removed, might stay â†’ '?'
Card 3 â†’ might be removed, might stay â†’ '?'
Output: ???

ğŸ§  Intuition Behind the Logic

We can simulate the range of definitely removed cards:

top â†’ number of sure top removals ('0')

bottom â†’ position of sure bottom removals ('1')

both â†’ number of flexible removals ('2')

At any time:

'0' removes topmost â†’ moves top pointer rightward.

'1' removes bottommost â†’ moves bottom pointer leftward.

'2' â†’ could go to either side, so we canâ€™t fix its direction yet.

So at the end:

Minimum possible removed top cards = top

Maximum possible removed top cards = top + both

Minimum possible removed bottom cards = n - bottom

Maximum possible removed bottom cards = n - bottom + both

This gives us ranges of cards that might be gone.

âš™ï¸ Code Walkthrough
Code:
#include <bits/stdc++.h>
using namespace std;
int main() {
    int t;
    cin>>t;
    while(t--){
        int n,k;
        cin>>n>>k;
        string r;
        cin>>r;
        if(k==n){
            string s(n,'-');
            cout<<s<<endl;
            continue;
        }
        string s(n,'+');
        int top=-1;
        int bottom=n;
        int both=0;
        for(int i=0;i<k;i++){
            if(r[i]=='1') bottom--;
            else if(r[i]=='0') top++;
            else both++;
        }
        int maxtop=top+both;
        int maxbottom=bottom-both;
        for(int i=0;i<n;i++){
            if(i<=top) s[i]='-';
            else if(i>=bottom) s[i]='-';
            else if(i<=maxtop || i>=maxbottom) s[i]='?';
        }
        cout<<s<<endl;
    }
}

ğŸ” Explanation of Variables
Variable	Meaning
top	last definitely removed index from top (due to '0')
bottom	first definitely remaining index from bottom
both	number of flexible removals ('2')
maxtop	max possible top removed cards
maxbottom	max possible bottom index that can be removed
ğŸ§¾ Step-by-step Working

1ï¸âƒ£ Initialize deck representation:
All cards initially '+' (present).

2ï¸âƒ£ For every character in string r:

'0' â†’ increase top (move top boundary up)

'1' â†’ decrease bottom (move bottom boundary down)

'2' â†’ count as both

3ï¸âƒ£ After counting:

Cards 0 to top are definitely removed ('-')

Cards bottom to n-1 are definitely removed ('-')

Cards between [top+1, maxtop] or [maxbottom, bottom-1] are uncertain ('?')

Others remain '+'

ğŸ” Dry Run Example
Input:
n = 7, k = 5
s = "01201"


Step 1:
'0' â†’ remove top â†’ top = 0
'1' â†’ remove bottom â†’ bottom = 6
'2' â†’ both++ (now 1)
'0' â†’ top = 1
'1' â†’ bottom = 5

Final:

top = 1
bottom = 5
both = 1
maxtop = 2
maxbottom = 4


Now fill result for i = 0..6:

i	Card	Condition	Result
0	1	i <= top	'-'
1	2	i <= top	'-'
2	3	i <= maxtop	'?'
3	4	Between	'+'
4	5	i >= maxbottom	'?'
5	6	i >= bottom	'-'
6	7	i >= bottom	'-'

âœ… Output â†’ --?+?--

ğŸ§¾ Final Revision Notes
ğŸ”¹ Concept:

Determine definite, possible, and remaining cards after certain removals from top/bottom.

ğŸ”¹ Key Observations:

'0' â†’ definitely top removal

'1' â†’ definitely bottom removal

'2' â†’ flexible (top/bottom unknown)

ğŸ”¹ Logic:

Count how many '0', '1', and '2' actions there are.

top = number of '0's removed from top.

bottom = n - number of '1's removed from bottom.

Range of possible removed = expand top upward and bottom downward using '2'.

ğŸ”¹ Output Marking:
Range	Meaning	Symbol
â‰¤ top or â‰¥ bottom	Definitely removed	'-'
Between top+1 and maxtop, or between maxbottom and bottom-1	Could be removed or not	'?'
Otherwise	Definitely remains	'+'
