ğŸ§© Problem Understanding

We are given a string s consisting of 'a' and 'b'.

In one operation, you can swap adjacent characters.
Goal â†’ Make all characters of one type (either 'a' or 'b') together in exactly one continuous block.
Other characters can be on either or both sides.

We must find the minimum number of swaps to reach such a state.

âœ… Valid final forms

For example, if s = "aaabbbaaa"

All 'b's are in one continuous block â†’ âœ… valid.

If s = "bbbaaaaaabbb"

All 'a's are together â†’ âœ… valid.

If s = "aaaaabbbb" or "bbbbaaaaa"

Both letters form one block each â†’ âœ… valid.

âš™ï¸ Key Idea

We need all â€˜aâ€™s together or all â€˜bâ€™s together.

We can compute:

minimum swaps to make all â€˜aâ€™s together, OR

minimum swaps to make all â€˜bâ€™s together.

Then take the minimum of the two.

ğŸ’¡ Observation

Swapping is equivalent to shifting characters so that all same-type characters are contiguous.

Letâ€™s consider the indices of all 'a's in the string.

For example:
s = "bababa"
Indices: 0 1 2 3 4 5
Positions of 'a': [1, 3, 5]

We want all 'a's to be contiguous â€” i.e., occupy consecutive positions.

To minimize total swaps, the median position acts as the â€œcenterâ€.

ğŸ§® Formula for Swaps

Let:

pos[] = indices of all 'a's.

k = len(pos) (number of â€˜aâ€™s).

If we want them to be consecutive:

target_positions = [median - k//2, ..., median + k//2]


The number of swaps =
sum(|pos[i] - target_positions[i]|) for all i.

Same logic applies for 'b'.

Finally:

answer = min(swaps_to_group_a, swaps_to_group_b)

ğŸ§  Example Walkthrough
Example 1:

s = "abab"

Positions of 'a': [0, 2]
â†’ k = 2, median = 2nd element (1st index) â†’ 2

Target positions for 2 elements: [1, 2]

Swaps for 'a':

|0 - 1| + |2 - 2| = 1 + 0 = 1


Positions of 'b': [1, 3]
Target positions: [2, 3]

|1 - 2| + |3 - 3| = 1 + 0 = 1


âœ… Minimum = 1

Output â†’ 1

ğŸ§® Example 2:

s = "bababa"
positions of 'a' = [1, 3, 5]
median = 3
target positions = [2, 3, 4]

|1-2| + |3-3| + |5-4| = 1 + 0 + 1 = 2


positions of 'b' = [0, 2, 4]
median = 2
target = [1, 2, 3]

|0-1| + |2-2| + |4-3| = 1 + 0 + 1 = 2


âœ… Minimum = 2

Output â†’ 2

âœ… C++ Code (Optimal, O(n) per test)
#include <bits/stdc++.h>
using namespace std;

long long calc(string &s, char ch) {
    vector<long long> pos;
    for (int i = 0; i < s.size(); i++) {
        if (s[i] == ch) pos.push_back(i);
    }
    if (pos.empty()) return (long long)1e18;

    int k = pos.size();
    int mid_index = k / 2;
    long long median = pos[mid_index];

    long long moves = 0;
    for (int i = 0; i < k; i++) {
        long long target = median - mid_index + i;
        moves += llabs(pos[i] - target);
    }
    return moves;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        string s;
        cin >> s;

        long long ans = min(calc(s, 'a'), calc(s, 'b'));
        if (ans == (long long)1e18) ans = 0;

        cout << ans << "\n";
    }
    return 0;
}

ğŸ§¾ Example Input
5
4
abab
6
bababa
7
abababa
2
ab
1
b

âœ… Output
1
2
2
0
0

ğŸ Complexity

Each test runs in O(n).

Works for sum(n) â‰¤ 2Ã—10âµ easily.
