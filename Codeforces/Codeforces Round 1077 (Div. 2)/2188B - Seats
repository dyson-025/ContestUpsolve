ğŸ” What are we trying to reach?

You start with some 1s already placed (no adjacent ones).
You want to add as few new 1s as possible so that:

There is no position left where you could add another 1
(i.e. every 0 has at least one neighbor that is 1).

So in the final configuration, every seat must be â€œblockedâ€ by a 1 within distance 1.

ğŸ§  Key observation

Look at the string as segments of consecutive 0s separated by 1s.

Each segment can be treated independently.

Case 1ï¸âƒ£ â€” Segment between two 1s

Example:

1 0000 1
  ^len=4


The seats right next to the boundary 1s are already unusable:

1 x 0 0 x 1


So usable free seats inside = len - 2.

To block all of them with minimum students, place students every 3 seats:

ğŸ‘‰ each student blocks itself and neighbors â†’ covers length 3

So needed students:

max(0, (len - 2) / 3 rounded up)

Case 2ï¸âƒ£ â€” Segment at boundary (start or end)

Example:

0000 1


Only one side blocked:

0 0 0 x 1


Effective usable seats = len - 1

Students needed:

(len - 1 + 2) / 3  = ceil((len - 1)/3)

Case 3ï¸âƒ£ â€” Whole string is zeros

Example:

00000


No sides blocked â†’ usable len

Students needed:

(len + 2) / 3 = ceil(len/3)

âœ… Algorithm

For each test case:

1ï¸âƒ£ Count initial 1s â†’ this contributes to answer
2ï¸âƒ£ Scan string and find zero segments [lâ€¦r]
3ï¸âƒ£ For each segment length len:

If both sides have 1
add += max(0, (len - 2 + 2) / 3)

Else if one side has 1
add += (len - 1 + 2) / 3

Else (whole string zeros)
add += (len + 2) / 3

4ï¸âƒ£ Answer = initial ones + add

ğŸ§© Clean CF-style C++ code
#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(NULL);

    int t; cin>>t;
    while(t--){
        int n; cin>>n;
        string s; cin>>s;

        int ans = 0;

        // count existing students
        for(char c:s) if(c=='1') ans++;

        for(int i=0;i<n;){
            if(s[i]=='1'){ i++; continue; }

            int j=i;
            while(j<n && s[j]=='0') j++;

            int len = j-i;

            bool left = (i-1>=0 && s[i-1]=='1');
            bool right = (j<n && s[j]=='1');

            if(left && right){
                int usable = len-2;
                if(usable>0) ans += (usable+2)/3;
            }
            else if(left || right){
                int usable = len-1;
                if(usable>0) ans += (usable+2)/3;
            }
            else{
                ans += (len+2)/3;
            }

            i=j;
        }

        cout<<ans<<"\n";
    }
}

â­ Big intuition takeaway (important for contests)

This problem is really about:

Turning seating rule into coverage problem

Each 1 covers [i-1, i, i+1]

Minimize new placements â†’ greedy spacing every 3

This pattern appears a LOT in CF (strings / intervals / greedy).
