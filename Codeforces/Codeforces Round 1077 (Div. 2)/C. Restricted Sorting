ğŸ· Restricted Sorting â€” Revision Notes
ğŸ§  Problem Intuition

You can swap two elements only if:

|ai - aj| â‰¥ k


ğŸ‘‰ Larger k â†’ fewer swaps allowed
ğŸ‘‰ Need maximum k such that sorting is still possible.

ğŸ”¥ Core Insight

If array is not sorted â†’
We must ensure every misplaced element can move.

How can it move?

ğŸ‘‰ Either swap with minimum element (mn)
ğŸ‘‰ Or swap with maximum element (mx)

These act like swap hubs / intermediates.

âŒ When Element Gets Stuck

If for some misplaced ai:

ai - mn < k
AND
mx - ai < k


Then:

Can't swap with mn

Can't swap with mx
â†’ Element stuck â†’ Sorting impossible

âœ… Maximum k Allowed Per Element

For each misplaced element:

limit_i = max(ai - mn, mx - ai)


This is the largest k that still allows movement.

ğŸ¯ Final Answer

Since ALL misplaced elements must move:

Answer =
min over all misplaced elements:
    max(ai - mn, mx - ai)

âœ… Edge Case

If array already sorted:

Answer = -1


Because any k works (no swaps needed).

ğŸ’¡ Memory Trick

Each bad element says:

"Maximum k I can tolerate is X"


Answer = smallest X among them.

â± Complexity

Sorting â†’ O(n log n)
Traversal â†’ O(n)

â­ Final C++ Code
#include <bits/stdc++.h>
using namespace std;

#define fast_io ios::sync_with_stdio(false); cin.tie(nullptr);
#define ll long long

void solve() {
    int n;
    cin >> n;

    vector<ll> a(n);
    for (auto &x : a) cin >> x;

    vector<ll> b = a;
    sort(b.begin(), b.end());

    // Already sorted
    if (a == b) {
        cout << -1 << "\n";
        return;
    }

    ll mn = b[0];
    ll mx = b[n - 1];

    ll ans = LLONG_MAX;

    for (int i = 0; i < n; i++) {
        if (a[i] != b[i]) {
            ll limit = max(a[i] - mn, mx - a[i]);
            ans = min(ans, limit);
        }
    }

    cout << ans << "\n";
}

int main() {
    fast_io;
    int t;
    cin >> t;
    while (t--) solve();
}

ğŸ§ª Example Mental Walk
a = [2,1,5,4,3]
sorted = [1,2,3,4,5]

mn = 1
mx = 5


Compute limits for bad elements â†’
Take minimum â†’ final k.

ğŸ† Contest Recognition Pattern

If you see:

Restricted swaps

Difference condition

Need max allowed parameter

Extremes (min/max) exist

ğŸ‘‰ Try using extreme values as connectors
ğŸ‘‰ Then find tightest constraint
