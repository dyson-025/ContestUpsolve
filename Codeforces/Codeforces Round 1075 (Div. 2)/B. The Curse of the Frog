ğŸ§¾ B. The Curse of the Frog â€” Notes
ğŸ§© Problem Essence

Each jump type i:

Normal jump â†’ forward ai

Every bi-th use â†’ rollback ci first

Goal:
ğŸ‘‰ Reach position â‰¥ x
ğŸ‘‰ Minimize rollbacks

ğŸš¨ Constraint Signal
x â‰¤ 1e18


So:
âŒ No DP on position
âŒ No BFS simulation
âœ… Math / Greedy / Cycle analysis

ğŸ§  Core Intuition

Movement happens in 2 phases:

ğŸŸ¢ Phase 1 â€” Free Jumps

Before first rollback:
You can use each jump type:

bi - 1 times


Distance gained free:

ai * (bi - 1)


Since free â†’ take from ALL types.

Total free distance:

start = Î£ ai (bi - 1)

ğŸ”´ Phase 2 â€” Rollback Cycles

After first rollback:
Pattern repeats:

bi jumps â†’ 1 rollback


Net gain per rollback cycle:

gain_i = ai * bi - ci

â­ Critical Insight

After free phase â†’
Always use jump type with maximum gain per rollback.

Let:

m = max(ai * bi - ci)


Because:
More gain per rollback â†’ fewer rollbacks needed.

ğŸ§® Final Math

Remaining distance after free phase:

rem = x - start

Case 1
rem <= 0


Answer:

0 rollbacks

Case 2
m <= 0


Meaning:
After rollback â†’ no forward progress

Answer:

-1

Case 3
Answer = ceil(rem / m)

ğŸ“Œ Final Formula Summary
start = Î£ ai (bi - 1)
m = max(ai bi - ci)

rem = x - start

if rem <= 0 â†’ 0
else if m <= 0 â†’ -1
else â†’ ceil(rem / m)

ğŸ’» Code (Clean CF Style)
#include <bits/stdc++.h>
using namespace std;

#define int long long

void solve() {
    int n, x;
    cin >> n >> x;

    vector<int> a(n), b(n), c(n);

    for (int i = 0; i < n; i++) {
        cin >> a[i] >> b[i] >> c[i];
    }

    int start = 0;          // total free distance
    int mx = LLONG_MIN;     // best gain per rollback

    for (int i = 0; i < n; i++) {
        start += a[i] * (b[i] - 1);
        mx = max(mx, a[i] * b[i] - c[i]);
    }

    int rem = x - start;

    if (rem <= 0) {
        cout << 0;
        return;
    }

    if (mx <= 0) {
        cout << -1;
        return;
    }

    cout << (rem + mx - 1) / mx;
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL);

    int t;
    cin >> t;
    while (t--) {
        solve();
        cout << "\n";
    }
}

ğŸ§  Why Taking All Free Jumps Works

Because:

No rollback cost

Only increases distance

No downside

So always optimal.

ğŸ§  Why Only Best Cycle After

Because rollback = expensive
So want:

Max distance / rollback


Classic efficiency optimization.

ğŸ”¥ Pattern Recognition

When you see:
âœ… Huge target (1e18)
âœ… Repeating penalty
âœ… Want minimum penalty count
âœ… Periodic behavior

Think:
ğŸ‘‰ Free phase + Best cycle gain

ğŸ§Š Mental One-Liner
Take all free distance
Then use best gain-per-rollback cycle

â­ Difficulty Tags

Greedy Math Optimization

Cycle Gain Analysis

Efficiency Maximization
