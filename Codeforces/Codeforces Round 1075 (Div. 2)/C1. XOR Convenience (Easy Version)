ğŸ“Œ C1. XOR Convenience (Easy) â€” Final Notes
ğŸ§© Problem Core

We need a permutation p[1â€¦n] such that:

For every i (2 â‰¤ i â‰¤ n-1)
There exists j (i â‰¤ j â‰¤ n) such that:

p[i] = p[j] âŠ• i

ğŸ” Key Observation

Rearrange condition:

p[i] = p[j] âŠ• i
â‡’ p[i] âŠ• i = p[j]


ğŸ‘‰ Means value at position i, XOR i, must appear somewhere to the right.

ğŸ’¡ Strong Greedy Idea

Try to satisfy condition using same j for all i.

Choose:

j = n


So force:

p[i] âŠ• i = p[n]


Let:

p[n] = 1


Then:

p[i] = i âŠ• 1

ğŸ§  XOR With 1 Pattern
Even âŠ• 1 â†’ Next odd
Odd âŠ• 1 â†’ Previous even


Example:

2 âŠ• 1 = 3
3 âŠ• 1 = 2
4 âŠ• 1 = 5
5 âŠ• 1 = 4


ğŸ‘‰ Numbers form pairs:

(2,3)
(4,5)
(6,7)
...

ğŸ“¦ Case Handling
âœ… Case 1: n is EVEN

We can perfectly pair numbers except 1 and n.

Construction:

p1 = n
pn = 1
Rest â†’ pair swap


Pattern:

p[2k]   = 2k+1
p[2k+1] = 2k

âœ… Case 2: n is ODD

Now after fixing:

pn = 1


Remaining numbers = even count â†’ can pair.

But one number still leftover â†’ put at position 1
(because position 1 has NO condition)

Construction:

p1 = n-1
pn = 1
Rest â†’ pair swap

ğŸ§  Memory Trick
Fix last â†’ 1
Middle â†’ swap pairs
First â†’ leftover biggest number

â± Complexity
Time: O(n)
Space: O(1)

ğŸ’» Final Code (Clean CP Version)
#include <bits/stdc++.h>
using namespace std;

#define int long long

void solve() {
    int n;
    cin >> n;

    if (n % 2 == 0) {
        // Even case
        cout << n << " ";
        for (int i = 2; i <= n - 2; i += 2) {
            cout << i + 1 << " " << i << " ";
        }
        cout << 1;
    } else {
        // Odd case
        cout << n - 1 << " ";
        for (int i = 2; i <= n - 3; i += 2) {
            cout << i + 1 << " " << i << " ";
        }
        cout << n << " " << 1;
    }

    cout << "\n";
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    cin >> t;
    while (t--) solve();
}

ğŸ§  Contest Thinking Pattern (MOST IMPORTANT)

When you see:

âœ… XOR
âœ… Permutation construction
âœ… Existential condition (there exists j)

Try:

Fix one index (like last index)

Force equation globally

Look for XOR pairing patterns (especially XOR 1, XOR power of 2)
