ğŸŒŸ KANADÃ‰â€™S PERFECT MULTIPLES â€” FULL NOTES (BASED ON YOUR CODE)
ğŸ”· Problem Requirement (Simple Words)

We want a set B such that:

1) Coverage Condition

Every array element ai must have at least one divisor in B.

2) Multiples Condition

If we take any b âˆˆ B,
then every multiple of b (â‰¤ k) must appear in the array.

Our goal:
âœ” Find smallest possible B
âŒ If impossible, print -1.

ğŸŒŸ Key Observations
Observation 1 â€” If b âˆˆ B

We must check all y = b, 2b, 3b, â€¦ â‰¤ k.
Each y must exist in array.

Observation 2 â€” Picking smaller b is better

Because:

Smaller b has more multiples â†’ covers more numbers.

Ensures minimal B size.

This is why GREEDY works.

ğŸŒŸ Your Strategy (100% Correct Logic)

We use:

s = sorted set of all unique elements in array

covered = set of numbers already covered by some previously chosen b

ans = our B set

ğŸ”· ALGORITHM (WHAT YOUR CODE DOES EXACTLY)
Step 1 â€” Insert all elements into sorted set s

Because duplicates donâ€™t matter.

Step 2 â€” Iterate over s in increasing order

For each number x:

âœ” If x is already in covered, skip X

Because some smaller divisor already covered it.

âœ” Else, choose x as a B candidate

Add x into ans.

Why?
Because x is the smallest uncovered number â€” best choice greedy-wise.

Step 3 â€” Validate x by checking all multiples

Check all y = 2x, 3x, 4x â€¦ â‰¤ k

If y âˆˆ s â†’ mark y as covered

Else â†’ INVALID â†’ no solution exists â†’ print -1

This enforces:

â€œAll multiples of b must appear in arrayâ€

Step 4 â€” If loop ends normally

Then ans contains the minimal complete B.

ğŸŒŸ Why This Works (Proof in 3 Lines)

A valid b must have all its multiples in the array â†’ you check this.

Greedy: choosing smallest b gives maximum coverage â†’ minimal B.

Any number that can be covered by smaller b gets auto-skipped â†’ optimal.

ğŸŒŸ FINAL COMPLETELY CLEAN CODE (YOUR LOGIC, POLISHED)
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    cin >> t;
    while (t--) {

        int n, k;
        cin >> n >> k;

        set<int> s; // unique sorted array values
        for (int i = 0; i < n; i++) {
            int x;
            cin >> x;
            s.insert(x);
        }

        bool ok = true;
        set<int> covered;
        vector<int> ans;

        // iterate over unique sorted values
        for (int x : s) {

            // already covered by smaller divisor
            if (covered.count(x)) 
                continue;

            // choose x in B
            ans.push_back(x);

            // check all multiples of x
            for (long long y = 1LL * x * 2; y <= k; y += x) {
                if (s.count(y))
                    covered.insert(y);
                else {
                    ok = false;        // missing multiple â†’ invalid
                    break;
                }
            }

            if (!ok) break;
        }

        if (!ok) {
            cout << -1 << "\n";
            continue;
        }

        cout << ans.size() << "\n";
        for (int x : ans) cout << x << " ";
        cout << "\n";
    }
}

ğŸŒŸ Short Revision Notes (One Page Summary)
âœ” Choose smallest uncovered number x â†’ put in B
âœ” Check all multiples y = x2, x3 â€¦ â‰¤ k

If y missing â†’ no B possible

âœ” Mark y as covered
âœ” Move to next x
âœ” Result = minimal valid B
