ðŸ“˜ C. Range Operation â€” Complete Notes
âœ… 1. Problem Summary (Simple Words)

You are given an array a[1..n].

You may pick one continuous subarray [l, r] and change all values in that range to:

(l + r)


Do this at most once.

Goal â†’ maximize total array sum.

ðŸ“Œ 2. What happens if we apply the operation?
Original contribution of range:
âˆ‘ð‘–=ð‘™ð‘Ÿð‘Žð‘–i=lâˆ‘r	â€‹ai	â€‹
New contribution:

All elements become (l + r), so:

(râˆ’l+1)(l+r)
Net gain:
gain
(
ð‘™
,
ð‘Ÿ
)
=
(
ð‘Ÿ
âˆ’
ð‘™
+
1
)
(
ð‘™
+
ð‘Ÿ
)
âˆ’
âˆ‘
ð‘–
=
ð‘™
ð‘Ÿ
ð‘Ž
ð‘–
gain(l,r)=(râˆ’l+1)(l+r)âˆ’
i=l
âˆ‘
r
	â€‹

a
i
	â€‹


We must find the maximum gain over all l â‰¤ r.

Final answer:

sum of array
+
max
â¡
(
0
,
best gain
)
sum of array+max(0,best gain)
ðŸ’¡ 3. Convert gain into a usable formula

Let prefix sum:

ð‘†
ð‘–
=
âˆ‘
ð‘˜
=
1
ð‘–
ð‘Ž
ð‘˜
S
i
	â€‹

=
k=1
âˆ‘
i
	â€‹

a
k
	â€‹


Then:

âˆ‘
ð‘–
=
ð‘™
ð‘Ÿ
ð‘Ž
ð‘–
=
ð‘†
ð‘Ÿ
âˆ’
ð‘†
ð‘™
âˆ’
1
i=l
âˆ‘
r
	â€‹

a
i
	â€‹

=S
r
	â€‹

âˆ’S
lâˆ’1
	â€‹


Now expand:

(
ð‘Ÿ
âˆ’
ð‘™
+
1
)
(
ð‘™
+
ð‘Ÿ
)
=
ð‘Ÿ
2
+
ð‘Ÿ
âˆ’
(
ð‘™
2
âˆ’
ð‘™
)
(râˆ’l+1)(l+r)=r
2
+râˆ’(l
2
âˆ’l)

So gain becomes:

gain
(
ð‘™
,
ð‘Ÿ
)
=
(
ð‘Ÿ
2
+
ð‘Ÿ
âˆ’
ð‘†
ð‘Ÿ
)
+
(
âˆ’
ð‘™
2
+
ð‘™
+
ð‘†
ð‘™
âˆ’
1
)
gain(l,r)=(r
2
+râˆ’S
r
	â€‹

)+(âˆ’l
2
+l+S
lâˆ’1
	â€‹

)

Define:

ð´
ð‘Ÿ
=
ð‘Ÿ
2
+
ð‘Ÿ
âˆ’
ð‘†
ð‘Ÿ
A
r
	â€‹

=r
2
+râˆ’S
r
	â€‹

ðµ
ð‘™
=
âˆ’
ð‘™
2
+
ð‘™
+
ð‘†
ð‘™
âˆ’
1
B
l
	â€‹

=âˆ’l
2
+l+S
lâˆ’1
	â€‹


Then:

gain
(
ð‘™
,
ð‘Ÿ
)
=
ð´
ð‘Ÿ
+
ðµ
ð‘™
gain(l,r)=A
r
	â€‹

+B
l
	â€‹


We want:

max
â¡
ð‘™
â‰¤
ð‘Ÿ
(
ð´
ð‘Ÿ
+
ðµ
ð‘™
)
lâ‰¤r
max
	â€‹

(A
r
	â€‹

+B
l
	â€‹

)
ðŸŽ¯ 4. Key Insight

While iterating r from 1..n, keep track of the maximum B_l for all l â‰¤ r.

Let:

left = max B_l seen so far


Then for each r:

gain = max(gain, A_r + left)


Finally:

answer = sum + gain

ðŸ§  5. Mapping this formula to your code

Your code:

left = max(left, -1LL*i*i + i + sum);


At this moment:

i = l

sum = S_{l-1}

So:

left = max(left, B_l)


Perfect.

Then:

gain = max(gain, 1LL*i*i + i - sum + left);


Here:

i = r

sum = S_r

So:

A_r = r*r + r - S_r
gain = max(gain, A_r + left)

ðŸ§© 6. Full Explanation of Your Code (Line-by-Line)

Here is your code with an explanation:

void solve() {
    ll n;
    cin >> n;
    vector<ll> v(n);

    // Input the array
    for(auto &it: v) cin >> it;

    ll sum = 0;   // prefix sum S_r
    ll left = 0;  // stores max B_l = -l*l + l + S_{l-1}
    ll gain = 0;  // stores best gain

    for(int i = 1; i <= n; i++) {

        // BEFORE updating sum -> sum = S_{i-1}
        // Update maximum B_l
        left = max(left, -1LL * i * i + i + sum);

        // Now include v[i-1] -> sum becomes S_i
        sum += v[i-1];

        // A_r = r*r + r - S_r
        // gain = maximum A_r + best B_l
        gain = max(gain, 1LL * i * i + i - sum + left);
    }

    // Maximum possible sum = original sum + best gain
    cout << sum + gain << endl;
}


This is optimal O(n).

ðŸ“Š 7. Visual Diagram

As r moves:

Compute A_r

Combine with best B_l

left stores the best l so far.

gain accumulates the optimal (l, r) pair.

ðŸ”¥ 8. Why the logic is correct

The problem reduces to maximizing a two-part expression.

One part depends only on l, the other only on r.

We transform the operation into a prefix-based max expression.

Using prefix sums avoids re-scanning ranges â†’ O(n).

Each r computes best possible l.

This is a classic DP + prefix maxima transformation used in many CF problems.

ðŸ 9. Final Complexity

Each element is processed once â†’ O(n)

No extra memory besides arrays â†’ O(1) extra

Works for n â‰¤ 2e5 comfortably.

âœ”ï¸ 10. Final Answer Structure

1ï¸âƒ£ Compute prefix sum
2ï¸âƒ£ For every r:

update best B_l

compute A_r + best B_l

3ï¸âƒ£ Add this gain to original sum.
