üßä C. Production of Snowmen ‚Äî COMPLETE FINAL NOTES
1Ô∏è‚É£ Problem in one line

You have 3 circular belts of snowballs (head, body, legs).
You choose starting positions (i, j, k) and build n snowmen.
Each snowman must satisfy:

head < body < legs


üëâ Count how many (i, j, k) make ALL snowmen stable.

2Ô∏è‚É£ Why brute force fails

i, j, k ‚Üí n¬≥ choices

For each choice, check n snowmen
‚Üí O(n‚Å¥) ‚ùå too slow

We need to reduce dimensions.

3Ô∏è‚É£ FIRST KEY IDEA ‚Äî Rotation trick üîÅ

Belts are circular.

If you rotate all three belts together,
you get the same snowmen, only in different order.

So:

(i, j, k) ‚â° (i-(j-1), 1, k-(j-1))

üî• Conclusion

We can fix j = 0 (or j = 1) and:

Count valid (i, k)

Multiply final answer by n

This removes one loop.

4Ô∏è‚É£ Problem after fixing j

Now we only need:

A[i+t] < B[t] < C[k+t]   for all t

5Ô∏è‚É£ SECOND KEY IDEA ‚Äî Independence üß† (MOST IMPORTANT)

Look carefully:

i affects only:

A[i+t] < B[t]


k affects only:

B[t] < C[k+t]


üî• i and k do NOT affect each other

So instead of checking pairs (i, k):

‚úî Count valid i
‚úî Count valid k
‚úî Multiply

6Ô∏è‚É£ What is a ‚Äúvalid i‚Äù?

Fix j = 0.

i is valid if for ALL positions:

A[i+t] < B[t]


If even one position fails, that i is bad.

7Ô∏è‚É£ What is a ‚Äúvalid k‚Äù?

Similarly, k is valid if for ALL positions:

B[t] < C[k+t]

8Ô∏è‚É£ Final counting formula ‚úÖ

Let:

goodI = number of valid i

goodK = number of valid k

Then:

answer = goodI √ó goodK √ó n


Why √ó n?
‚Üí Because j can be any rotation, all equivalent.

9Ô∏è‚É£ Complexity (why this passes)

Checking one shift = O(n)

Total shifts = 2n

Total = O(n¬≤) per test case ‚úÖ
Given total n ‚â§ 5000, this is safe.

üîü Tiny example (intuition lock üîí)
A = [1, 2]
B = [3, 4]
C = [5, 4]


Valid i:

i = 0 ‚Üí OK

i = 1 ‚Üí OK
‚Üí goodI = 2

Valid k:

k = 0 ‚Üí FAIL

k = 1 ‚Üí OK
‚Üí goodK = 1

Answer:

2 √ó 1 √ó 2 = 4

1Ô∏è‚É£1Ô∏è‚É£ FINAL CLEAN C++ CODE (EDITORIAL STYLE)
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    cin >> t;

    while (t--) {
        int n;
        cin >> n;

        vector<int> A(n), B(n), C(n);
        for (int &x : A) cin >> x;
        for (int &x : B) cin >> x;
        for (int &x : C) cin >> x;

        int goodI = 0, goodK = 0;

        // Count valid i (A vs B)
        for (int i = 0; i < n; i++) {
            bool ok = true;
            for (int t = 0; t < n; t++) {
                if (A[(i + t) % n] >= B[t]) {
                    ok = false;
                    break;
                }
            }
            if (ok) goodI++;
        }

        // Count valid k (B vs C)
        for (int k = 0; k < n; k++) {
            bool ok = true;
            for (int t = 0; t < n; t++) {
                if (B[t] >= C[(k + t) % n]) {
                    ok = false;
                    break;
                }
            }
            if (ok) goodK++;
        }

        long long answer = 1LL * goodI * goodK * n;
        cout << answer << "\n";
    }

    return 0;
}

1Ô∏è‚É£2Ô∏è‚É£ ONE-LINE MEMORY TRICK üß†

Fix the middle belt.
Slide left ‚Üí count good i.
Slide right ‚Üí count good k.
Multiply and rotate.

üèÜ Why this problem is GOLD

This single problem teaches you:

Circular arrays

Rotation equivalence

Dimension reduction

Independent constraints

Turning n¬≥ ‚Üí n¬≤

This is ~1500‚Äì1600 CF rating thinking.
