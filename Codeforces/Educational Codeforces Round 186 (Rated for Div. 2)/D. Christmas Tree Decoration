ğŸŒŸ D. Christmas Tree Decoration â€” COMPLETE MASTER NOTES ğŸŒŸ
1ï¸âƒ£ Problem in Simple Words

There are n people and n+1 boxes

Box 0 â†’ common box

Box i â†’ personal box of person i

People act in a permutation order, repeatedly in rounds

On their turn, person i can take a decoration from:

their own box i

or box 0

âŒ If at any time both boxes are empty, permutation is bad

âœ… Count how many permutations are safe (fair)

2ï¸âƒ£ Key Observation (MOST IMPORTANT)

Best strategy:
Every person should use their own box first,
and only use box 0 as backup.

If this greedy strategy fails â†’ no strategy can save it.

So we only simulate this greedy approach.

3ï¸âƒ£ Rounds Concept (Critical Insight)

Let:

s = total number of decorations


Each full round uses n decorations.

So:

k = s / n


ğŸ‘‰ Every person must survive k full rounds
ğŸ‘‰ Each person must hang at least k decorations

4ï¸âƒ£ Simulating k Rounds (Greedy)

For each person i = 1 to n:

Take from own box:

take = min(a[i], k)


Remaining taken from box 0:

a[0] -= (k - take)


Update:

a[i] -= take

5ï¸âƒ£ Impossible Conditions âŒ

If any of these happens â†’ answer is 0

a[0] < 0
â†’ common box ran out

a[i] > 1 after k rounds
â†’ person cannot finish in later rounds

6ï¸âƒ£ After k Rounds â€” Last Round Logic

Let:

z = number of people whose own box is empty
a0 = remaining decorations in box 0


Only a0 empty people can be helped.

Remaining:

x = z - a0


ğŸ‘‰ These x people cannot act in last round
ğŸ‘‰ So they must be placed at the END of permutation

Extra invalid case:

if (a0 > z) â†’ impossible

7ï¸âƒ£ Permutation Counting (Core Math)
Situation:

Total people = n

Empty people = z

End positions = x = z - a0

Step-by-step counting:

Choose which x empty people go to end â†’ C(z, x)

Arrange them â†’ x!

Arrange remaining people â†’ (n - x)!

Initial formula:
C(z, x) Ã— x! Ã— (n - x)!

8ï¸âƒ£ Formula Simplification âœ‚ï¸

Using:

C(z, x) = z! / (x! (z-x)!)


Multiply by x! and substitute x = z - a0:

âœ… Final formula:
ğ‘§
!
Ã—
(
ğ‘›
âˆ’
ğ‘§
+
ğ‘
0
)
!
Ã·
ğ‘
0
!
z!Ã—(nâˆ’z+a
0
	â€‹

)!Ã·a
0
	â€‹

!
	â€‹

9ï¸âƒ£ Modular Arithmetic Concepts ğŸ§ 
Why modular inverse?

Division not allowed in modulo

MOD is prime (998244353)

Using Fermatâ€™s Little Theorem:

ğ‘¥
âˆ’
1
â‰¡
ğ‘¥
ğ‘€
ğ‘‚
ğ·
âˆ’
2
(
m
o
d
ğ‘€
ğ‘‚
ğ·
)
x
âˆ’1
â‰¡x
MODâˆ’2
(modMOD)

So:

/ a0!  â†’  Ã— inverse(a0!)

ğŸ”Ÿ Special Case: a0 = 0

Box 0 helps nobody

All empty people must go to the end

Formula becomes:

z! Ã— (n - z)!


Handled automatically by formula.

1ï¸âƒ£1ï¸âƒ£ C++ Errors We Faced (IMPORTANT LESSONS)
âŒ Error 1: Array size not constant
ll N = 55;
ll fac[N];   // âŒ WRONG


âœ… Fix:

const int N = 55;
ll fac[N];

âŒ Error 2: Inverse of wrong thing
inv(a0);   // âŒ WRONG


âœ… Fix:

inv(fact[a0]);   // divide by factorial

âŒ Error 3: power() returned wrong value
return y;   // âŒ WRONG


âœ… Fix:

return res;

âŒ Error 4: Variable not declared

Reason: array failed to compile â†’ compiler never saw it
Fix root cause (array size)

1ï¸âƒ£2ï¸âƒ£ FINAL EDITORIAL-LEVEL CODE (WITH COMMENTS)
#include <bits/stdc++.h>
using namespace std;

// ---------- FAST I/O ----------
#define fast_io ios::sync_with_stdio(false); cin.tie(nullptr);

// ---------- SHORTCUTS ----------
#define ll long long
#define all(x) (x).begin(), (x).end()
#define endl '\n'

// ---------- MOD ----------
const ll mod = 998244353;

// ---------- FACTORIAL ----------
const int N = 55;          // n â‰¤ 50
ll fact[N];

// ---------- FAST POWER (a^b % mod) ----------
ll power(ll a, ll b) {
    ll res = 1;
    while (b > 0) {
        if (b & 1) res = (res * a) % mod;
        a = (a * a) % mod;
        b >>= 1;
    }
    return res;
}

// ---------- MODULAR INVERSE ----------
ll inv(ll x) {
    return power(x, mod - 2);
}

void solve() {
    ll n;
    cin >> n;

    vector<ll> a(n + 1);
    for (auto &x : a) cin >> x;

    ll s = accumulate(all(a), 0LL);
    ll k = s / n;

    bool bad = false;
    ll z = 0;   // empty people

    for (int i = 1; i <= n; i++) {
        ll take = min(a[i], k);
        a[i] -= take;
        a[0] -= (k - take);

        if (a[i] == 0) z++;
        if (a[i] > 1 || a[0] < 0) {
            bad = true;
            break;
        }
    }

    if (a[0] > z) bad = true;

    if (bad) {
        cout << 0 << endl;
        return;
    }

    // z! * (n - z + a0)! / a0!
    ll ans = fact[z];
    ans = ans * fact[n - z + a[0]] % mod;
    ans = ans * inv(fact[a[0]]) % mod;

    cout << ans << endl;
}

int main() {
    fast_io;

    // Precompute factorials
    fact[0] = 1;
    for (int i = 1; i < N; i++)
        fact[i] = fact[i - 1] * i % mod;

    int t;
    cin >> t;
    while (t--)
        solve();

    return 0;
}

ğŸ§  ONE-PAGE MEMORY SUMMARY

Own box first, box 0 backup

k = total / n

Count empty people

Some must go to end

Choose â†’ arrange â†’ arrange

Divide by factorial â†’ use inverse

Array size must be constant

ğŸ† FINAL VERDICT

If you understand this one problem, you learned:

Greedy proof

Rounds thinking

Permutation counting

Modular inverse

C++ compilation rules

This is 1600-1700 CF level thinking.
