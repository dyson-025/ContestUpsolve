â­ CYCLIC MERGING â€” NOTES (VERY CLEAR & SHORT)
ğŸ”¥ Problem Summary

You have n numbers arranged in a ring.
Each operation:

Pick two adjacent numbers x and y

Merge them into max(x, y)

Cost of merge = max(x, y)

Repeat until only one number remains

Find minimum total cost

â­ Key Observations
1. Cost of each merge = larger of the two numbers

So merging (2,7) costs 7,
merging (5,1) costs 5, etc.

2. The largest element in the array NEVER disappears

If max = M:

When merging M with any x:

new value = max(M, x) = M

M survives

So M stays till the end

ğŸ’¡ This means we can break the ring at the maximum value M.

â­ Transform Ring â†’ Line

Example ring:

a1 - a2 - a3 - ... - an - (back to a1)


Since the maximum never dies,
we â€œcutâ€ the ring at that point â†’ becomes a straight line.

â­ Total cost on a line

On a line:

a1, a2, a3, ..., an


The greedy strategy (always take smallest element) will always produce cost:

ğ‘š
ğ‘
ğ‘¥
(
ğ‘
1
,
ğ‘
2
)
+
ğ‘š
ğ‘
ğ‘¥
(
ğ‘
2
,
ğ‘
3
)
+
.
.
.
+
ğ‘š
ğ‘
ğ‘¥
(
ğ‘
ğ‘›
âˆ’
1
,
ğ‘
ğ‘›
)
max(a
1
	â€‹

,a
2
	â€‹

)+max(a
2
	â€‹

,a
3
	â€‹

)+...+max(a
nâˆ’1
	â€‹

,a
n
	â€‹

)

This is fixed.
It does not depend on the order of merges.

â­ Total cost on a ring

A ring has one extra edge:

(a_n, a_1)


So ring cost becomes:

ğ‘š
ğ‘
ğ‘¥
(
ğ‘
1
,
ğ‘
2
)
+
.
.
.
+
ğ‘š
ğ‘
ğ‘¥
(
ğ‘
ğ‘›
âˆ’
1
,
ğ‘
ğ‘›
)
+
ğ‘š
ğ‘
ğ‘¥
(
ğ‘
ğ‘›
,
ğ‘
1
)
max(a
1
	â€‹

,a
2
	â€‹

)+...+max(a
nâˆ’1
	â€‹

,a
n
	â€‹

)+max(a
n
	â€‹

,a
1
	â€‹

)

Or simply:

Make a[n] = a[0], then:

âˆ‘
ğ‘–
=
0
ğ‘›
âˆ’
1
ğ‘š
ğ‘
ğ‘¥
(
ğ‘
[
ğ‘–
]
,
ğ‘
[
ğ‘–
+
1
]
)
i=0
âˆ‘
nâˆ’1
	â€‹

max(a[i],a[i+1])
â­ But this sum OVERCOUNTS the global maximum

Because when we â€œcutâ€ the ring at max,
one of the max-adjacency contributions is extra.

ğŸ‘‰ So subtract the global maximum once.

â­ FINAL FORMULA (IMPORTANT)
Answer
=
(
âˆ‘
ğ‘–
=
0
ğ‘›
âˆ’
1
max
â¡
(
ğ‘
[
ğ‘–
]
,
ğ‘
[
ğ‘–
+
1
]
)
)
âˆ’
max
â¡
(
ğ‘
)
Answer=(
i=0
âˆ‘
nâˆ’1
	â€‹

max(a[i],a[i+1]))âˆ’max(a)
â­ Steps to Solve

Find index of maximum element M.

Add all max(a[i], a[i+1]) around the ring
(with a[n] = a[0]).

Subtract M once.

Print the result.

â­ Time Complexity

O(n) per test case

Very fast, fits constraints

â­ Example

Input:

1 1 3 2


Compute ring max-pairs:

max(1,1) = 1
max(1,3) = 3
max(3,2) = 3
max(2,1) = 2
Sum = 9


Subtract maximum = 3

Answer =

9 âˆ’ 3 = 6

â­ Clear C++ Code
long long solve(vector<long long> &a) {
    int n = a.size();
    long long mx = *max_element(a.begin(), a.end());

    a.push_back(a[0]); // make ring simple

    long long sum = 0;
    for (int i = 0; i < n; i++)
        sum += max(a[i], a[i+1]);

    return sum - mx;
}
