üß† D1. Sub-RBS (Easy)
1Ô∏è‚É£ Problem Rephrasing

You are given a regular bracket sequence s.

You must pick a non-empty subsequence t such that:

t is also a regular bracket sequence

t is lexicographically better than s under this rule:

Comparison:

Longer prefix wins

Or, at first different position, '(' is better than ')'

So '(' > ')'.

Goal:
üëâ Maximize |t| such that t > s.

2Ô∏è‚É£ When is it Impossible?

If s is already the best possible sequence, i.e.:

(((((.....)))))


All opening brackets first, then all closing.

This is the lexicographically maximum RBS for its length.

In this case:

Any subsequence will be ‚â§ s

So answer = -1

Example:

()
(())()

3Ô∏è‚É£ Key Observation

To be better than s, at the first position where we differ:

t[i] = '('
s[i] = ')'


So in s, we need a ')' somewhere, after which there exists '(' later
(otherwise we can‚Äôt replace it by '(' in subsequence order).

So we need the pattern:

... ) ... (


If such a pattern does NOT exist ‚Üí answer = -1.

4Ô∏è‚É£ How to Maximize Length?

Once we find that a ')(' pattern exists, the best strategy is:

üëâ Remove exactly one matching pair "()" in the middle,
so the resulting subsequence is:

(original length n) - 2


And it will still be a valid RBS and better than s.

So answer = n - 2

But only if such improvement is possible.

5Ô∏è‚É£ Implementation Logic

Scan string:

found = false ‚Üí have we seen a ')'?

cnt = 0 ‚Üí number of '(' after first ')'

For each char:

If ')' ‚Üí found = true

If '(' and found ‚Üí cnt++

If cnt > 1 ‚Üí print n - 2
Else ‚Üí print -1

Why >1?
We need at least two '(' after some ')' to maintain RBS validity after deletion.

6Ô∏è‚É£ Time & Space

Time: O(n) per test

Total: O(2e5) ‚úÖ

Space: O(1)

7Ô∏è‚É£ Final Insight
Condition in s	Result
No ")(" pattern	-1
Exists and safe	n - 2
