🧾 Notes: Longest Balanced Substring II
link: https://leetcode.com/problems/longest-balanced-substring-ii/description/
🔢 Problem Statement

You are given a string s consisting only of characters 'a', 'b', and 'c'.

A substring of s is balanced if all distinct characters in it appear the same number of times.

You must return the length of the longest balanced substring.

🧩 Example 1

Input:
s = "abbac"
Output: 4
Explanation: "abba" has 'a' = 2, 'b' = 2 → balanced.

🧩 Example 2

Input:
s = "aabcc"
Output: 3
Explanation: "abc" → 'a','b','c' each appear once → balanced.

🎯 Goal

Find the maximum length of any substring where
all distinct characters occur equally often.

🧠 Intuition

If we try every substring → O(n²) (too slow for n ≤ 10⁵).
We need a prefix-based O(n) method.

We use frequency difference tracking to know when a substring becomes balanced.

⚖️ Key Idea — Prefix Differences

Let:

count_a = number of 'a' so far
count_b = number of 'b' so far
count_c = number of 'c' so far


A substring s[L+1 ... R] is balanced if:

(count_a[R] - count_a[L]) = (count_b[R] - count_b[L]) = (count_c[R] - count_c[L])


Each character’s count increased by the same amount.

We can’t check this directly for all pairs —
instead, we track relative differences between counts.

💡 Define State

Define:

diff_ab = count_a - count_b
diff_ac = count_a - count_c


At every index, the pair (diff_ab, diff_ac) represents the relative frequency pattern among a, b, c up to that point.

⚙️ Core Observation

If at two positions i and j we have the same (diff_ab, diff_ac):

Then the substring between them (i+1 ... j) has equal increases in all characters —
✅ Balanced substring found.

That’s because:

(count_a[j] - count_a[i])
(count_b[j] - count_b[i])
(count_c[j] - count_c[i])


will all differ equally.

📘 Algorithm

Initialize counts:

int a = 0, b = 0, c = 0;


Create a map to remember the first index of each state (diff_ab, diff_ac):

map<pair<int,int>, int> firstIndex;
firstIndex[{0,0}] = -1; // Base case before starting


Iterate through the string:

Update count of a, b, or c.

Compute:

diff_ab = a - b;
diff_ac = a - c;


If (diff_ab, diff_ac) was seen before → balanced substring found.

length = i - firstIndex[state];


Otherwise, store the current index for this state.

Keep track of maxLen.

⏱️ Complexity
Operation	Complexity
Time	O(n)
Space	O(n)

Efficient for n up to 10⁵.

✅ Code Implementation (C++)
#include <bits/stdc++.h>
using namespace std;

int longestBalancedSubstring(string s) {
    int count_a = 0, count_b = 0, count_c = 0;
    map<pair<int, int>, int> firstIndex;
    firstIndex[{0, 0}] = -1; // base case

    int maxLen = 0;

    for (int i = 0; i < s.size(); i++) {
        if (s[i] == 'a') count_a++;
        else if (s[i] == 'b') count_b++;
        else count_c++;

        int diff_ab = count_a - count_b;
        int diff_ac = count_a - count_c;

        pair<int, int> state = {diff_ab, diff_ac};

        if (firstIndex.count(state)) {
            maxLen = max(maxLen, i - firstIndex[state]);
        } else {
            firstIndex[state] = i;
        }
    }
    return maxLen;
}

int main() {
    string s;
    cin >> s;
    cout << longestBalancedSubstring(s) << endl;
    return 0;
}

🧾 Example Walkthrough

s = "abbac"

Index	Char	a	b	c	diff_ab	diff_ac	State	Seen Before?	Length	Max
-1	—	0	0	0	0	0	(0,0)	—	—	—
0	a	1	0	0	1	1	(1,1)	No	—	0
1	b	1	1	0	0	1	(0,1)	No	—	0
2	b	1	2	0	-1	1	(-1,1)	No	—	0
3	a	2	2	0	0	2	(0,2)	No	—	0
4	c	2	2	1	0	1	(0,1)	Yes (at 1)	4-1=3	3

Final answer = 4 (from substring "abba").

🧭 Why It Works (Conceptual)

Think of (diff_ab, diff_ac) as your position in a 2D grid.

Reading 'a' moves you right and up (increases both diffs)

Reading 'b' moves you left (decreases diff_ab)

Reading 'c' moves you down (decreases diff_ac)

Whenever you return to the same coordinate,
it means the net movement in a, b, c between those two points was equal —
so that substring is balanced.

🧩 Extra Tip (for 2 characters version)

If the string had only 'a' and 'b',
you’d only need one difference count_a - count_b.

Same difference repeating → equal number of a and b between them.

This 3-character version just extends that to 2 differences:
(a-b, a-c).

🧠 Summary
Concept	Description
Balanced substring	Equal frequency of distinct chars
State	(count_a - count_b, count_a - count_c)
Key condition	Same state seen twice → balanced substring between them
Approach	Prefix sum + hash map
Time	O(n)
Space	O(n)
Technique used	Prefix difference hashing
✅ Final Answer Template
int longestBalancedSubstring(string s) {
    int a=0,b=0,c=0,ans=0;
    map<pair<int,int>,int> mp;
    mp[{0,0}] = -1;

    for(int i=0;i<s.size();i++){
        if(s[i]=='a') a++;
        else if(s[i]=='b') b++;
        else c++;

        int diff_ab = a - b;
        int diff_ac = a - c;

        pair<int,int> state = {diff_ab, diff_ac};

        if(mp.count(state)) ans = max(ans, i - mp[state]);
        else mp[state] = i;
    }
    return ans;
}
