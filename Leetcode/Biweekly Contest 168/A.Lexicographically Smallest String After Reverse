ğŸ§  Problem Summary

You are given a string s of lowercase letters.
You must do exactly one of these operations:

Reverse first k characters (for some 1 â‰¤ k â‰¤ n), OR

Reverse last k characters.

After that, return the lexicographically smallest possible string.

âš™ï¸ Intuition (Logic)

We just need to try all possible k (1 to n) and perform both operations:

Reverse prefix â†’ s[:k][::-1]

Reverse suffix â†’ s[-k:][::-1]

Then keep the smallest string seen so far.

Why this works:

Each operation gives a new possible string.

Lexicographic comparison tells which is smallest.

Since n â‰¤ 1000, we can safely test all possibilities (O(nÂ²)).

ğŸ’» C++ Code (Final Version)
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    string lexicographicallySmallestString(string s) {
        int n = s.size();
        string ans = s;

        for (int k = 1; k <= n; k++) {
            // Reverse first k characters
            string first = s;
            reverse(first.begin(), first.begin() + k);
            ans = min(ans, first);

            // Reverse last k characters
            string last = s;
            reverse(last.end() - k, last.end());
            ans = min(ans, last);
        }

        return ans;
    }
};

int main() {
    Solution sol;
    cout << sol.lexicographicallySmallestString("dcab") << endl; // acdb
    cout << sol.lexicographicallySmallestString("abba") << endl; // aabb
    cout << sol.lexicographicallySmallestString("zxy") << endl;  // xzy
}

ğŸª„ Step-by-Step Example

Input â†’ "dcab"

k	Operation	Result
1	reverse first 1 â†’ "dcab"	
2	reverse first 2 â†’ "cdab"	
3	reverse first 3 â†’ "acdb" âœ…	
4	reverse first 4 â†’ "bacd"	
3	reverse last 3 â†’ "dabc"	
4	reverse last 4 â†’ "bacd"	

âœ… Final answer â†’ "acdb"

â±ï¸ Complexity

Time: O(nÂ²)

Space: O(n)

Perfectly fine for n â‰¤ 1000.

ğŸ“˜ Key Takeaways

Always test both prefix and suffix reversals.

Lexicographic comparison is just normal < comparison between strings.

You can brute force safely when n is small (~1000).

This pattern (try all prefix/suffix modifications) appears often in string manipulation problems.
