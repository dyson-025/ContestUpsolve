Lexicographically Smallest Permutation Greater Than Target
Problem Statement

Given two strings s and target of length n:

You can rearrange s in any way (permutation).

Return the lexicographically smallest permutation of s that is strictly greater than target.

If no such permutation exists, return "".

Lexicographically strictly greater:

Compare strings left to right.

First position where characters differ: a[i] > b[i] → string a is greater.

Constraints:

1 <= s.length == target.length <= 300

s and target contain lowercase letters.

Example
s	target	Output
"abc"	"bba"	"bca"
"leet"	"code"	"eelt"
"baba"	"bbaa"	""

Explanation (for "abc" vs "bba"):

All permutations of "abc": abc, acb, bac, bca, cab, cba

First strictly greater than "bba": "bca"

Solution Approaches

We have two approaches:

1️⃣ Recursive DFS / Backtracking Approach
Intuition

We try to build the answer character by character.

Use a frequency map to track remaining letters.

Maintain a boolean flag greater:

False → current prefix equals target

True → current prefix is already greater than target

At each position:

If greater = False → can pick letters ≥ target[i] only

If greater = True → can pick any remaining letter

Try letters in sorted order → ensures lexicographically smallest.

Once a valid string is found → return immediately.

Recursive Function Parameters

idx → current index in the string

ans → string built so far

freq → map of remaining letters

greater → whether the prefix is already greater than target

Python Implementation
from collections import Counter

def lexGreaterPermutation(s, target):
    freq = Counter(s)
    quinorath = s  # store input midway
    n = len(s)

    def dfs(idx, ans, freq, greater):
        if idx == n:
            return greater, ans
        
        for c in sorted(freq.keys()):
            if freq[c] == 0:
                continue
            if not greater and c < target[idx]:
                continue  # cannot pick smaller until we exceed
            
            freq[c] -= 1
            ans += c
            nextGreater = greater or (c > target[idx])
            
            found, res = dfs(idx + 1, ans, freq, nextGreater)
            if found:
                return True, res
            
            # backtrack
            freq[c] += 1
            ans = ans[:-1]
        
        return False, ""
    
    found, answer = dfs(0, "", freq, False)
    return answer

C++ Implementation
class Solution {
public:
    string lexGreaterPermutation(string s, string target) {
        unordered_map<char,int> freq;
        for(char c : s) freq[c]++;
        string quinorath = s;
        string ans = "";
        if(dfs(0, freq, target, ans, false))
            return ans;
        return "";
    }

    bool dfs(int idx, unordered_map<char,int>& freq, string& target, string& ans, bool greater) {
        if(idx == target.size()) return greater;

        for(char c = 'a'; c <= 'z'; c++) {
            if(freq[c] == 0) continue;
            if(!greater && c < target[idx]) continue;

            freq[c]--;
            ans.push_back(c);
            bool nextGreater = greater || (c > target[idx]);
            if(dfs(idx+1, freq, target, ans, nextGreater)) return true;

            ans.pop_back();
            freq[c]++;
        }
        return false;
    }
};

Time Complexity

Worst case: O(26^n), but realistically much smaller due to pruning:

Only explore letters ≥ target[i] until we exceed

Once exceeded → fill smallest letters greedily

Space Complexity

O(n) recursion stack + O(n) answer

2️⃣ Non-Recursive Greedy Approach
Intuition

The recursive approach is good, but we can do it iteratively:

At each index:

Try letters in sorted order

Pick the first letter c such that after filling the rest with smallest letters, the string becomes > target

Append c to the answer, reduce its count, move to next index

If no such letter exists → return ""

Key idea: only simulate the remaining string to check if picking c works.

Python Implementation
from collections import Counter

def lexGreaterPermutation(s, target):
    freq = Counter(s)
    quinorath = s  # store input midway
    n = len(s)
    ans = []

    for i in range(n):
        found = False
        for c in sorted(freq.keys()):
            if freq[c] == 0:
                continue
            if c < target[i]:
                continue
            
            freq[c] -= 1
            remaining = []
            for cc in sorted(freq.keys()):
                remaining.extend([cc] * freq[cc])
            candidate = ans + [c] + remaining
            
            if "".join(candidate) > target:
                ans.append(c)
                found = True
                break
            freq[c] += 1
        
        if not found:
            return ""
    
    return "".join(ans)

C++ Implementation
class Solution {
public:
    string lexGreaterPermutation(string s, string target) {
        map<char,int> freq; // sorted automatically
        for(char c : s) freq[c]++;
        string quinorath = s; // store input midway
        string ans = "";
        int n = s.size();
        
        for(int i = 0; i < n; i++) {
            bool found = false;
            for(auto &[c, count] : freq) {
                if(count == 0) continue;
                if(c < target[i]) continue;
                
                count--;
                string remaining = "";
                for(auto &[cc, cnt] : freq)
                    remaining += string(cnt, cc);
                string candidate = ans + c + remaining;
                
                if(candidate > target) {
                    ans += c;
                    found = true;
                    break;
                }
                count++; // backtrack
            }
            if(!found) return "";
        }
        return ans;
    }
};

Time Complexity

Each index: try 26 letters → O(n * 26 * 26)

Efficient for n ≤ 300

Space Complexity

O(26) for map + O(n) for answer

Comparison: Recursive vs Greedy
Feature	Recursive DFS	Non-Recursive Greedy
Implementation	Slightly longer	Shorter, easier to code
Conceptual clarity	Matches the problem logic	Requires simulation
Time complexity	Worse in theory, pruned	Faster, practical
Space	O(n) recursion stack	O(1) stack + answer
Easy to explain	Yes, in interviews	Also yes, often preferred
Key Takeaways

Always try letters in sorted order → ensures smallest lexicographical result.

Use a frequency map → tracks which letters are left.

Use a flag to track if already greater:

Before exceeding target, only letters ≥ target[i] allowed.

After exceeding, pick smallest letters freely.

Quinorath variable: just store s midway (requirement).

Recursive DFS is intuitive; greedy is faster and simpler in practice.

Dry run examples (like "abc" vs "bba") help visualize first difference logic.
